<!DOCTYPE html>

<html lang="en" data-content_root="../../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>geoopt.manifolds.base &#8212; geoopt 0.1.1 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../../../_static/basic.css?v=686e5160" />
    <link rel="stylesheet" type="text/css" href="../../../_static/alabaster.css?v=27fed22d" />
    <link rel="stylesheet" type="text/css" href="../../../_static/plot_directive.css" />
    <script src="../../../_static/documentation_options.js?v=a58bc63e"></script>
    <script src="../../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for geoopt.manifolds.base</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span><span class="w"> </span><span class="nn">abc</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">torch.nn</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">itertools</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Union</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Manifold&quot;</span><span class="p">,</span> <span class="s2">&quot;ScalingInfo&quot;</span><span class="p">]</span>


<div class="viewcode-block" id="ScalingInfo">
<a class="viewcode-back" href="../../../devguide.html#geoopt.manifolds.base.ScalingInfo">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ScalingInfo</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Scaling info for each argument that requires rescaling.</span>

<span class="sd">  .. code:: python</span>

<span class="sd">    scaled_value = value * scaling ** power if power != 0 else value</span>

<span class="sd">  For results it is not always required to set powers of scaling, then it is no-op.</span>

<span class="sd">  The convention for this info is the following. The output of a function is either a tuple or a single object.</span>
<span class="sd">  In any case, outputs are treated as positionals. Function inputs, in contrast, are treated by keywords.</span>
<span class="sd">  It is a common practice to maintain function signature when overriding, so this way may be considered</span>
<span class="sd">  as a sufficient in this particular scenario. The only required info for formula above is ``power``.</span>
<span class="sd">  &quot;&quot;&quot;</span>

  <span class="c1"># marks method to be not working with Scaled wrapper</span>
  <span class="n">NotCompatible</span> <span class="o">=</span> <span class="nb">object</span><span class="p">()</span>
  <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;kwargs&quot;</span><span class="p">,</span> <span class="s2">&quot;results&quot;</span><span class="p">]</span>

  <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">results</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">results</span> <span class="o">=</span> <span class="n">results</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span>     <span class="o">=</span> <span class="n">kwargs</span></div>



<div class="viewcode-block" id="ScalingStorage">
<a class="viewcode-back" href="../../../devguide.html#geoopt.manifolds.base.ScalingStorage">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ScalingStorage</span><span class="p">(</span><span class="nb">dict</span><span class="p">):</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Helper class to make implementation transparent.</span>

<span class="sd">This is just a dictionary with additional overridden ``__call__``</span>
<span class="sd">for more explicit and elegant API to declare members. A usage example may be found in :class:`Manifold`.</span>

<span class="sd">Methods that require rescaling when wrapped into :class:`Scaled` should be defined as follows:</span>

<span class="sd">1. Regular methods like ``dist``, ``dist2``, ``expmap``, ``retr`` etc. that are already present in the base class</span>
<span class="sd">do not require registration â€” it has already happened in the base :class:`Manifold` class.</span>

<span class="sd">2. New methods (like in :class:`PoincareBall`) should be treated with care.</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        class PoincareBall(Manifold):</span>
<span class="sd">            # make a class copy of __scaling__ info. Default methods are already present there</span>
<span class="sd">            __scaling__ = Manifold.__scaling__.copy()</span>
<span class="sd">            ... # here come regular implementation of the required methods</span>

<span class="sd">            @__scaling__(ScalingInfo(1))  # rescale output according to rule `out * scaling ** 1`</span>
<span class="sd">            def dist0(self, x: torch.Tensor, *, dim=-1, keepdim=False):</span>
<span class="sd">                return math.dist0(x, c=self.c, dim=dim, keepdim=keepdim)</span>

<span class="sd">            @__scaling__(ScalingInfo(u=-1))  # rescale argument `u` according to the rule `out * scaling ** -1`</span>
<span class="sd">            def expmap0(self, u: torch.Tensor, *, dim=-1, project=True):</span>
<span class="sd">                res = math.expmap0(u, c=self.c, dim=dim)</span>
<span class="sd">                if project:</span>
<span class="sd">                    return math.project(res, c=self.c, dim=dim)</span>
<span class="sd">                else:</span>
<span class="sd">                    return res</span>
<span class="sd">            ... # other special methods implementation</span>

<span class="sd">3. Some methods are not compliant with the above rescaling rules. We should mark them as `NotCompatible`:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        # continuation of the PoincareBall definition</span>
<span class="sd">        @__scaling__(ScalingInfo.NotCompatible)</span>
<span class="sd">        def mobius_fn_apply(</span>
<span class="sd">            self, fn: callable, x: torch.Tensor, *args, dim=-1, project=True, **kwargs</span>
<span class="sd">        ):</span>
<span class="sd">            res = math.mobius_fn_apply(fn, x, *args, c=self.c, dim=dim, **kwargs)</span>
<span class="sd">            if project:</span>
<span class="sd">                return math.project(res, c=self.c, dim=dim)</span>
<span class="sd">            else:</span>
<span class="sd">                return res</span>
<span class="sd">&quot;&quot;&quot;</span>


  <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scaling_info</span><span class="p">:</span> <span class="n">ScalingInfo</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">register</span><span class="p">(</span><span class="n">fn</span><span class="p">):</span>
      <span class="bp">self</span><span class="p">[</span><span class="n">fn</span><span class="o">.</span><span class="vm">__name__</span><span class="p">]</span> <span class="o">=</span> <span class="n">scaling_info</span>
      <span class="k">return</span> <span class="n">fn</span>

    <span class="k">return</span> <span class="n">register</span>

<div class="viewcode-block" id="ScalingStorage.copy">
<a class="viewcode-back" href="../../../devguide.html#geoopt.manifolds.base.ScalingStorage.copy">[docs]</a>
  <span class="k">def</span><span class="w"> </span><span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="Manifold">
<a class="viewcode-back" href="../../../devguide.html#geoopt.manifolds.base.Manifold">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Manifold</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">,</span> <span class="n">metaclass</span><span class="o">=</span><span class="n">abc</span><span class="o">.</span><span class="n">ABCMeta</span><span class="p">):</span>
  <span class="n">__scaling__</span> <span class="o">=</span> <span class="n">ScalingStorage</span><span class="p">()</span>  <span class="c1"># will be filled along with implementation below</span>
  <span class="n">name</span>        <span class="o">=</span> <span class="kc">None</span>
  <span class="n">ndim</span>        <span class="o">=</span> <span class="kc">None</span>
  <span class="n">reversible</span>  <span class="o">=</span> <span class="kc">None</span>
  <span class="n">forward</span>     <span class="o">=</span> <span class="bp">NotImplemented</span>

  <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

  <span class="nd">@property</span>
  <span class="k">def</span><span class="w"> </span><span class="nf">device</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Manifold device.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Optional[torch.device]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">p</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">buffers</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">()),</span> <span class="kc">None</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">p</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">p</span><span class="o">.</span><span class="n">device</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">return</span> <span class="kc">None</span>

  <span class="nd">@property</span>
  <span class="k">def</span><span class="w"> </span><span class="nf">dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">dtype</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Manifold dtype.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Optional[torch.dtype]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">p</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">buffers</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">()),</span> <span class="kc">None</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">p</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">p</span><span class="o">.</span><span class="n">dtype</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">return</span> <span class="kc">None</span>

<div class="viewcode-block" id="Manifold.check_point">
<a class="viewcode-back" href="../../../devguide.html#geoopt.manifolds.base.Manifold.check_point">[docs]</a>
  <span class="k">def</span><span class="w"> </span><span class="nf">check_point</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">explain</span><span class="o">=</span><span class="kc">False</span>
  <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span> <span class="nb">bool</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Check if point is valid to be used with the manifold.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : torch.Tensor</span>
<span class="sd">      point on the manifold</span>
<span class="sd">    explain: bool</span>
<span class="sd">      return an additional information on check</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    bool</span>
<span class="sd">      boolean indicating if tensor is valid and reason of failure if False</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This check is compatible to what optimizer expects, last dimensions are treated as manifold dimensions</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ok</span><span class="p">,</span> <span class="n">reason</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_shape</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="s2">&quot;x&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">explain</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">ok</span><span class="p">,</span> <span class="n">reason</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">ok</span></div>


<div class="viewcode-block" id="Manifold.assert_check_point">
<a class="viewcode-back" href="../../../devguide.html#geoopt.manifolds.base.Manifold.assert_check_point">[docs]</a>
  <span class="k">def</span><span class="w"> </span><span class="nf">assert_check_point</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span> <span class="nb">bool</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Check if point is valid to be used with the manifold and raise an error with informative message on failure.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : torch.Tensor</span>
<span class="sd">      point on the manifold</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This check is compatible to what optimizer expects, last dimensions are treated as manifold dimensions</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">ok</span><span class="p">,</span> <span class="n">reason</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_shape</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="s2">&quot;x&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">ok</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
        <span class="s2">&quot;`x` seems to be not valid &quot;</span>
        <span class="s2">&quot;tensor for </span><span class="si">{}</span><span class="s2"> manifold.</span><span class="se">\n</span><span class="s2">error: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">reason</span><span class="p">)</span>
      <span class="p">)</span></div>


<div class="viewcode-block" id="Manifold.check_vector">
<a class="viewcode-back" href="../../../devguide.html#geoopt.manifolds.base.Manifold.check_vector">[docs]</a>
  <span class="k">def</span><span class="w"> </span><span class="nf">check_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">explain</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Check if vector is valid to be used with the manifold.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    u : torch.Tensor</span>
<span class="sd">      vector on the tangent plane</span>
<span class="sd">    explain: bool</span>
<span class="sd">      return an additional information on check</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    bool</span>
<span class="sd">      boolean indicating if tensor is valid and reason of failure if False</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This check is compatible to what optimizer expects, last dimensions are treated as manifold dimensions</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ok</span><span class="p">,</span> <span class="n">reason</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_shape</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="s2">&quot;u&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">explain</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">ok</span><span class="p">,</span> <span class="n">reason</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">ok</span></div>


<div class="viewcode-block" id="Manifold.assert_check_vector">
<a class="viewcode-back" href="../../../devguide.html#geoopt.manifolds.base.Manifold.assert_check_vector">[docs]</a>
  <span class="k">def</span><span class="w"> </span><span class="nf">assert_check_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Check if vector is valid to be used with the manifold and raise an error with informative message on failure.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    u : torch.Tensor</span>
<span class="sd">      vector on the tangent plane</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This check is compatible to what optimizer expects, last dimensions are treated as manifold dimensions</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">ok</span><span class="p">,</span> <span class="n">reason</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_shape</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="s2">&quot;u&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">ok</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
        <span class="s2">&quot;`u` seems to be not valid &quot;</span>
        <span class="s2">&quot;tensor for </span><span class="si">{}</span><span class="s2"> manifold.</span><span class="se">\n</span><span class="s2">error: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">reason</span><span class="p">)</span>
      <span class="p">)</span></div>


<div class="viewcode-block" id="Manifold.check_point_on_manifold">
<a class="viewcode-back" href="../../../devguide.html#geoopt.manifolds.base.Manifold.check_point_on_manifold">[docs]</a>
  <span class="k">def</span><span class="w"> </span><span class="nf">check_point_on_manifold</span><span class="p">(</span>
      <span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">explain</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="mf">1e-5</span>
  <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span> <span class="nb">bool</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Check if point :math:`x` is lying on the manifold.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : torch.Tensor</span>
<span class="sd">      point on the manifold</span>
<span class="sd">    atol: float</span>
<span class="sd">      absolute tolerance as in :func:`numpy.allclose`</span>
<span class="sd">    rtol: float</span>
<span class="sd">      relative tolerance as in :func:`numpy.allclose`</span>
<span class="sd">    explain: bool</span>
<span class="sd">      return an additional information on check</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    bool</span>
<span class="sd">      boolean indicating if tensor is valid and reason of failure if False</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This check is compatible to what optimizer expects, last dimensions are treated as manifold dimensions</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ok</span><span class="p">,</span> <span class="n">reason</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_shape</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="s2">&quot;x&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ok</span><span class="p">:</span>
      <span class="n">ok</span><span class="p">,</span> <span class="n">reason</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_point_on_manifold</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="n">atol</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="n">rtol</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">explain</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">ok</span><span class="p">,</span> <span class="n">reason</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">ok</span></div>


<div class="viewcode-block" id="Manifold.assert_check_point_on_manifold">
<a class="viewcode-back" href="../../../devguide.html#geoopt.manifolds.base.Manifold.assert_check_point_on_manifold">[docs]</a>
  <span class="k">def</span><span class="w"> </span><span class="nf">assert_check_point_on_manifold</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Check if point :math`x` is lying on the manifold and raise an error with informative message on failure.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : torch.Tensor</span>
<span class="sd">      point on the manifold</span>
<span class="sd">    atol: float</span>
<span class="sd">      absolute tolerance as in :func:`numpy.allclose`</span>
<span class="sd">    rtol: float</span>
<span class="sd">      relative tolerance as in :func:`numpy.allclose`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">assert_check_point</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">ok</span><span class="p">,</span> <span class="n">reason</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_point_on_manifold</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="n">atol</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="n">rtol</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">ok</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
        <span class="s2">&quot;`x` seems to be a tensor &quot;</span>
        <span class="s2">&quot;not lying on </span><span class="si">{}</span><span class="s2"> manifold.</span><span class="se">\n</span><span class="s2">error: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">reason</span><span class="p">)</span>
      <span class="p">)</span></div>


<div class="viewcode-block" id="Manifold.check_vector_on_tangent">
<a class="viewcode-back" href="../../../devguide.html#geoopt.manifolds.base.Manifold.check_vector_on_tangent">[docs]</a>
  <span class="k">def</span><span class="w"> </span><span class="nf">check_vector_on_tangent</span><span class="p">(</span>
      <span class="bp">self</span><span class="p">,</span>
      <span class="n">x</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
      <span class="n">u</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
      <span class="o">*</span><span class="p">,</span>
      <span class="n">ok_point</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
      <span class="n">explain</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
      <span class="n">atol</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">,</span>
      <span class="n">rtol</span><span class="o">=</span><span class="mf">1e-5</span>
  <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span> <span class="nb">bool</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Check if :math:`u` is lying on the tangent space to x.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : torch.Tensor</span>
<span class="sd">        point on the manifold</span>
<span class="sd">    u : torch.Tensor</span>
<span class="sd">        vector on the tangent space to :math:`x`</span>
<span class="sd">    atol: float</span>
<span class="sd">        absolute tolerance as in :func:`numpy.allclose`</span>
<span class="sd">    rtol: float</span>
<span class="sd">        relative tolerance as in :func:`numpy.allclose`</span>
<span class="sd">    explain: bool</span>
<span class="sd">        return an additional information on check</span>
<span class="sd">    ok_point: bool</span>
<span class="sd">        is a check for point required?</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    bool</span>
<span class="sd">        boolean indicating if tensor is valid and reason of failure if False</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">ok_point</span><span class="p">:</span>
      <span class="n">ok</span><span class="p">,</span> <span class="n">reason</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_shape</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="s2">&quot;x&quot;</span><span class="p">)</span>
      <span class="k">if</span> <span class="n">ok</span><span class="p">:</span>
        <span class="n">ok</span><span class="p">,</span> <span class="n">reason</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_shape</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="s2">&quot;u&quot;</span><span class="p">)</span>
      <span class="k">if</span> <span class="n">ok</span><span class="p">:</span>
        <span class="n">ok</span><span class="p">,</span> <span class="n">reason</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_point_on_manifold</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="n">atol</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="n">rtol</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">ok</span> <span class="o">=</span> <span class="kc">True</span>
      <span class="n">reason</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">if</span> <span class="n">ok</span><span class="p">:</span>
      <span class="n">ok</span><span class="p">,</span> <span class="n">reason</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_vector_on_tangent</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="n">atol</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="n">rtol</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">explain</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">ok</span><span class="p">,</span> <span class="n">reason</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">ok</span></div>


<div class="viewcode-block" id="Manifold.assert_check_vector_on_tangent">
<a class="viewcode-back" href="../../../devguide.html#geoopt.manifolds.base.Manifold.assert_check_vector_on_tangent">[docs]</a>
  <span class="k">def</span><span class="w"> </span><span class="nf">assert_check_vector_on_tangent</span><span class="p">(</span>
      <span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">u</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">ok_point</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="mf">1e-5</span>
  <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Check if :math:`u` is lying on the tangent space to x and raise an error on fail.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : torch.Tensor</span>
<span class="sd">      point on the manifold</span>
<span class="sd">    u : torch.Tensor</span>
<span class="sd">      vector on the tangent space to :math:`x`</span>
<span class="sd">    atol: float</span>
<span class="sd">      absolute tolerance as in :func:`numpy.allclose`</span>
<span class="sd">    rtol: float</span>
<span class="sd">      relative tolerance as in :func:`numpy.allclose`</span>
<span class="sd">    ok_point: bool</span>
<span class="sd">      is a check for point required?</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">ok_point</span><span class="p">:</span>
      <span class="n">ok</span><span class="p">,</span> <span class="n">reason</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_shape</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="s2">&quot;x&quot;</span><span class="p">)</span>
      <span class="k">if</span> <span class="n">ok</span><span class="p">:</span>
        <span class="n">ok</span><span class="p">,</span> <span class="n">reason</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_shape</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="s2">&quot;u&quot;</span><span class="p">)</span>
      <span class="k">if</span> <span class="n">ok</span><span class="p">:</span>
        <span class="n">ok</span><span class="p">,</span> <span class="n">reason</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_point_on_manifold</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="n">atol</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="n">rtol</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">ok</span>      <span class="o">=</span> <span class="kc">True</span>
      <span class="n">reason</span>  <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">ok</span><span class="p">:</span>
      <span class="n">ok</span><span class="p">,</span> <span class="n">reason</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_vector_on_tangent</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="n">atol</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="n">rtol</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">ok</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
        <span class="s2">&quot;`u` seems to be a tensor &quot;</span>
        <span class="s2">&quot;not lying on tangent space to `x` for </span><span class="si">{}</span><span class="s2"> manifold.</span><span class="se">\n</span><span class="s2">error: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
          <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">reason</span>
        <span class="p">)</span>
      <span class="p">)</span></div>


<div class="viewcode-block" id="Manifold.dist">
<a class="viewcode-back" href="../../../devguide.html#geoopt.manifolds.base.Manifold.dist">[docs]</a>
  <span class="nd">@__scaling__</span><span class="p">(</span><span class="n">ScalingInfo</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
  <span class="k">def</span><span class="w"> </span><span class="nf">dist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">keepdim</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute distance between 2 points on the manifold that is the shortest path along geodesics.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : torch.Tensor</span>
<span class="sd">      point on the manifold</span>
<span class="sd">    y : torch.Tensor</span>
<span class="sd">      point on the manifold</span>
<span class="sd">    keepdim : bool</span>
<span class="sd">      keep the last dim?</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    torch.Tensor</span>
<span class="sd">      distance between two points</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>


<div class="viewcode-block" id="Manifold.dist2">
<a class="viewcode-back" href="../../../devguide.html#geoopt.manifolds.base.Manifold.dist2">[docs]</a>
  <span class="nd">@__scaling__</span><span class="p">(</span><span class="n">ScalingInfo</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
  <span class="k">def</span><span class="w"> </span><span class="nf">dist2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">keepdim</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute squared distance between 2 points on the manifold that is the shortest path along geodesics.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : torch.Tensor</span>
<span class="sd">      point on the manifold</span>
<span class="sd">    y : torch.Tensor</span>
<span class="sd">      point on the manifold</span>
<span class="sd">    keepdim : bool</span>
<span class="sd">      keep the last dim?</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    torch.Tensor</span>
<span class="sd">      squared distance between two points</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">keepdim</span><span class="o">=</span><span class="n">keepdim</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span></div>


<div class="viewcode-block" id="Manifold.retr">
<a class="viewcode-back" href="../../../devguide.html#geoopt.manifolds.base.Manifold.retr">[docs]</a>
  <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
  <span class="nd">@__scaling__</span><span class="p">(</span><span class="n">ScalingInfo</span><span class="p">(</span><span class="n">u</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span>
  <span class="k">def</span><span class="w"> </span><span class="nf">retr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">u</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Perform a retraction from point :math:`x` with given direction :math:`u`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : torch.Tensor</span>
<span class="sd">      point on the manifold</span>
<span class="sd">    u : torch.Tensor</span>
<span class="sd">      tangent vector at point :math:`x`</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    torch.Tensor</span>
<span class="sd">      transported point</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>


<div class="viewcode-block" id="Manifold.expmap">
<a class="viewcode-back" href="../../../devguide.html#geoopt.manifolds.base.Manifold.expmap">[docs]</a>
  <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
  <span class="nd">@__scaling__</span><span class="p">(</span><span class="n">ScalingInfo</span><span class="p">(</span><span class="n">u</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span>
  <span class="k">def</span><span class="w"> </span><span class="nf">expmap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">u</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Perform an exponential map :math:`\operatorname{Exp}_x(u)`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : torch.Tensor</span>
<span class="sd">      point on the manifold</span>
<span class="sd">    u : torch.Tensor</span>
<span class="sd">      tangent vector at point :math:`x`</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    torch.Tensor</span>
<span class="sd">      transported point</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>


<div class="viewcode-block" id="Manifold.logmap">
<a class="viewcode-back" href="../../../devguide.html#geoopt.manifolds.base.Manifold.logmap">[docs]</a>
  <span class="nd">@__scaling__</span><span class="p">(</span><span class="n">ScalingInfo</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
  <span class="k">def</span><span class="w"> </span><span class="nf">logmap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Perform an logarithmic map :math:`\operatorname{Log}_{x}(y)`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : torch.Tensor</span>
<span class="sd">      point on the manifold</span>
<span class="sd">    y : torch.Tensor</span>
<span class="sd">      point on the manifold</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    torch.Tensor</span>
<span class="sd">      tangent vector</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>


<div class="viewcode-block" id="Manifold.expmap_transp">
<a class="viewcode-back" href="../../../devguide.html#geoopt.manifolds.base.Manifold.expmap_transp">[docs]</a>
  <span class="nd">@__scaling__</span><span class="p">(</span><span class="n">ScalingInfo</span><span class="p">(</span><span class="n">u</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span>
  <span class="k">def</span><span class="w"> </span><span class="nf">expmap_transp</span><span class="p">(</span>
      <span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">u</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span>
  <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Perform an exponential map and vector transport from point :math:`x` with given direction :math:`u`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : torch.Tensor</span>
<span class="sd">      point on the manifold</span>
<span class="sd">    u : torch.Tensor</span>
<span class="sd">      tangent vector at point :math:`x`</span>
<span class="sd">    v : torch.Tensor</span>
<span class="sd">      tangent vector at point :math:`x` to be transported</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    torch.Tensor</span>
<span class="sd">      transported point</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expmap</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
    <span class="n">v_transp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transp</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">y</span><span class="p">,</span> <span class="n">v_transp</span></div>


<div class="viewcode-block" id="Manifold.retr_transp">
<a class="viewcode-back" href="../../../devguide.html#geoopt.manifolds.base.Manifold.retr_transp">[docs]</a>
  <span class="nd">@__scaling__</span><span class="p">(</span><span class="n">ScalingInfo</span><span class="p">(</span><span class="n">u</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span>
  <span class="k">def</span><span class="w"> </span><span class="nf">retr_transp</span><span class="p">(</span>
      <span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">u</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span>
  <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Perform a retraction + vector transport at once.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : torch.Tensor</span>
<span class="sd">      point on the manifold</span>
<span class="sd">    u : torch.Tensor</span>
<span class="sd">      tangent vector at point :math:`x`</span>
<span class="sd">    v : torch.Tensor</span>
<span class="sd">      tangent vector at point :math:`x` to be transported</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Tuple[torch.Tensor, torch.Tensor]</span>
<span class="sd">      transported point and vectors</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Sometimes this is a far more optimal way to preform retraction + vector transport</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">retr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
    <span class="n">v_transp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transp</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">y</span><span class="p">,</span> <span class="n">v_transp</span></div>


<div class="viewcode-block" id="Manifold.transp_follow_retr">
<a class="viewcode-back" href="../../../devguide.html#geoopt.manifolds.base.Manifold.transp_follow_retr">[docs]</a>
  <span class="nd">@__scaling__</span><span class="p">(</span><span class="n">ScalingInfo</span><span class="p">(</span><span class="n">u</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span>
  <span class="k">def</span><span class="w"> </span><span class="nf">transp_follow_retr</span><span class="p">(</span>
      <span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">u</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span>
  <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Perform vector transport following :math:`u`: :math:`\mathfrak{T}_{x\to\operatorname{retr}(x, u)}(v)`.</span>

<span class="sd">    This operation is sometimes is much more simpler and can be optimized.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : torch.Tensor</span>
<span class="sd">      point on the manifold</span>
<span class="sd">    u : torch.Tensor</span>
<span class="sd">      tangent vector at point :math:`x`</span>
<span class="sd">    v : torch.Tensor</span>
<span class="sd">      tangent vector at point :math:`x` to be transported</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    torch.Tensor</span>
<span class="sd">      transported tensor</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">retr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">transp</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span></div>


<div class="viewcode-block" id="Manifold.transp_follow_expmap">
<a class="viewcode-back" href="../../../devguide.html#geoopt.manifolds.base.Manifold.transp_follow_expmap">[docs]</a>
  <span class="nd">@__scaling__</span><span class="p">(</span><span class="n">ScalingInfo</span><span class="p">(</span><span class="n">u</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span>
  <span class="k">def</span><span class="w"> </span><span class="nf">transp_follow_expmap</span><span class="p">(</span>
      <span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">u</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span>
  <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Perform vector transport following :math:`u`: :math:`\mathfrak{T}_{x\to\operatorname{Exp}(x, u)}(v)`.</span>

<span class="sd">    Here, :math:`\operatorname{Exp}` is the best possible approximation of the true exponential map.</span>
<span class="sd">    There are cases when the exact variant is hard or impossible implement, therefore a</span>
<span class="sd">    fallback, non-exact, implementation is used.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : torch.Tensor</span>
<span class="sd">      point on the manifold</span>
<span class="sd">    u : torch.Tensor</span>
<span class="sd">      tangent vector at point :math:`x`</span>
<span class="sd">    v : torch.Tensor</span>
<span class="sd">      tangent vector at point :math:`x` to be transported</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    torch.Tensor</span>
<span class="sd">      transported tensor</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expmap</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">transp</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span></div>


<div class="viewcode-block" id="Manifold.transp">
<a class="viewcode-back" href="../../../devguide.html#geoopt.manifolds.base.Manifold.transp">[docs]</a>
  <span class="k">def</span><span class="w"> </span><span class="nf">transp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Perform vector transport :math:`\mathfrak{T}_{x\to y}(v)`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : torch.Tensor</span>
<span class="sd">      start point on the manifold</span>
<span class="sd">    y : torch.Tensor</span>
<span class="sd">      target point on the manifold</span>
<span class="sd">    v : torch.Tensor</span>
<span class="sd">      tangent vector at point :math:`x`</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    torch.Tensor</span>
<span class="sd">      transported tensor</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>


<div class="viewcode-block" id="Manifold.inner">
<a class="viewcode-back" href="../../../devguide.html#geoopt.manifolds.base.Manifold.inner">[docs]</a>
  <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
  <span class="k">def</span><span class="w"> </span><span class="nf">inner</span><span class="p">(</span>
      <span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">u</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">v</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">keepdim</span><span class="o">=</span><span class="kc">False</span>
  <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Inner product for tangent vectors at point :math:`x`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : torch.Tensor</span>
<span class="sd">      point on the manifold</span>
<span class="sd">    u : torch.Tensor</span>
<span class="sd">      tangent vector at point :math:`x`</span>
<span class="sd">    v : Optional[torch.Tensor]</span>
<span class="sd">      tangent vector at point :math:`x`</span>
<span class="sd">    keepdim : bool</span>
<span class="sd">      keep the last dim?</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    torch.Tensor</span>
<span class="sd">      inner product (broadcasted)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>


<div class="viewcode-block" id="Manifold.component_inner">
<a class="viewcode-back" href="../../../devguide.html#geoopt.manifolds.base.Manifold.component_inner">[docs]</a>
  <span class="k">def</span><span class="w"> </span><span class="nf">component_inner</span><span class="p">(</span>
      <span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">u</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span> <span class="o">=</span> <span class="kc">None</span>
  <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Inner product for tangent vectors at point :math:`x` according to components of the manifold.</span>

<span class="sd">    The result of the function is same as ``inner`` with ``keepdim=True`` for</span>
<span class="sd">    all the manifolds except ProductManifold. For this manifold it acts different way</span>
<span class="sd">    computing inner product for each component and then building an output correctly</span>
<span class="sd">    tiling and reshaping the result.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : torch.Tensor</span>
<span class="sd">      point on the manifold</span>
<span class="sd">    u : torch.Tensor</span>
<span class="sd">      tangent vector at point :math:`x`</span>
<span class="sd">    v : Optional[torch.Tensor]</span>
<span class="sd">      tangent vector at point :math:`x`</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    torch.Tensor</span>
<span class="sd">      inner product component wise (broadcasted)</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The purpose of this method is better adaptive properties in optimization since ProductManifold</span>
<span class="sd">    will &quot;hide&quot; the structure in public API.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">keepdim</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>


<div class="viewcode-block" id="Manifold.norm">
<a class="viewcode-back" href="../../../devguide.html#geoopt.manifolds.base.Manifold.norm">[docs]</a>
  <span class="k">def</span><span class="w"> </span><span class="nf">norm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">u</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">keepdim</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Norm of a tangent vector at point :math:`x`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : torch.Tensor</span>
<span class="sd">      point on the manifold</span>
<span class="sd">    u : torch.Tensor</span>
<span class="sd">      tangent vector at point :math:`x`</span>
<span class="sd">    keepdim : bool</span>
<span class="sd">      keep the last dim?</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    torch.Tensor</span>
<span class="sd">      inner product (broadcasted)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">keepdim</span><span class="o">=</span><span class="n">keepdim</span><span class="p">)</span> <span class="o">**</span> <span class="mf">0.5</span></div>


<div class="viewcode-block" id="Manifold.proju">
<a class="viewcode-back" href="../../../devguide.html#geoopt.manifolds.base.Manifold.proju">[docs]</a>
  <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
  <span class="k">def</span><span class="w"> </span><span class="nf">proju</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">u</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Project vector :math:`u` on a tangent space for :math:`x`, usually is the same as :meth:`egrad2rgrad`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x torch.Tensor</span>
<span class="sd">      point on the manifold</span>
<span class="sd">    u torch.Tensor</span>
<span class="sd">      vector to be projected</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    torch.Tensor</span>
<span class="sd">      projected vector</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>


<div class="viewcode-block" id="Manifold.egrad2rgrad">
<a class="viewcode-back" href="../../../devguide.html#geoopt.manifolds.base.Manifold.egrad2rgrad">[docs]</a>
  <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
  <span class="k">def</span><span class="w"> </span><span class="nf">egrad2rgrad</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">u</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Transform gradient computed using autodiff to the correct Riemannian gradient for the point :math:`x`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x torch.Tensor</span>
<span class="sd">      point on the manifold</span>
<span class="sd">    u torch.Tensor</span>
<span class="sd">      gradient to be projected</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    torch.Tensor</span>
<span class="sd">      grad vector in the Riemannian manifold</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>


<div class="viewcode-block" id="Manifold.projx">
<a class="viewcode-back" href="../../../devguide.html#geoopt.manifolds.base.Manifold.projx">[docs]</a>
  <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
  <span class="k">def</span><span class="w"> </span><span class="nf">projx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Project point :math:`x` on the manifold.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x torch.Tensor</span>
<span class="sd">      point to be projected</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    torch.Tensor</span>
<span class="sd">      projected point</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>


<div class="viewcode-block" id="Manifold._check_shape">
<a class="viewcode-back" href="../../../devguide.html#geoopt.manifolds.base.Manifold._check_shape">[docs]</a>
  <span class="k">def</span><span class="w"> </span><span class="nf">_check_shape</span><span class="p">(</span>
      <span class="bp">self</span><span class="p">,</span> <span class="n">shape</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>
  <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span> <span class="nb">bool</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Util to check shape.</span>

<span class="sd">    Exhaustive implementation for checking if</span>
<span class="sd">    a given point has valid dimension size,</span>
<span class="sd">    shape, etc. It should return boolean and</span>
<span class="sd">    a reason of failure if check is not passed</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    shape : Tuple[int]</span>
<span class="sd">        shape of point on the manifold</span>
<span class="sd">    name : str</span>
<span class="sd">        name to be present in errors</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    bool, str or None</span>
<span class="sd">        check result and the reason of fail if any</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ok</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">ok</span><span class="p">:</span>
      <span class="n">reason</span> <span class="o">=</span> <span class="s2">&quot;&#39;</span><span class="si">{}</span><span class="s2">&#39; on the </span><span class="si">{}</span><span class="s2"> requires more than </span><span class="si">{}</span><span class="s2"> dim&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
          <span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span>
      <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">reason</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">return</span> <span class="n">ok</span><span class="p">,</span> <span class="n">reason</span></div>


<div class="viewcode-block" id="Manifold._assert_check_shape">
<a class="viewcode-back" href="../../../devguide.html#geoopt.manifolds.base.Manifold._assert_check_shape">[docs]</a>
  <span class="k">def</span><span class="w"> </span><span class="nf">_assert_check_shape</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shape</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Util to check shape and raise an error if needed.</span>

<span class="sd">    Exhaustive implementation for checking if</span>
<span class="sd">    a given point has valid dimension size,</span>
<span class="sd">    shape, etc. It will raise a ValueError if check is not passed</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    shape : tuple</span>
<span class="sd">      shape of point on the manifold</span>
<span class="sd">    name : str</span>
<span class="sd">      name to be present in errors</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ok</span><span class="p">,</span> <span class="n">reason</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_shape</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">ok</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">reason</span><span class="p">)</span></div>


<div class="viewcode-block" id="Manifold._check_point_on_manifold">
<a class="viewcode-back" href="../../../devguide.html#geoopt.manifolds.base.Manifold._check_point_on_manifold">[docs]</a>
  <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
  <span class="k">def</span><span class="w"> </span><span class="nf">_check_point_on_manifold</span><span class="p">(</span>
      <span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="mf">1e-5</span>
  <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span> <span class="nb">bool</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Util to check point lies on the manifold.</span>

<span class="sd">    Exhaustive implementation for checking if</span>
<span class="sd">    a given point lies on the manifold. It</span>
<span class="sd">    should return boolean and a reason of</span>
<span class="sd">    failure if check is not passed. You can</span>
<span class="sd">    assume assert_check_point is already</span>
<span class="sd">    passed beforehand</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x torch.Tensor</span>
<span class="sd">      point on the manifold</span>
<span class="sd">    atol: float</span>
<span class="sd">      absolute tolerance as in :func:`numpy.allclose`</span>
<span class="sd">    rtol: float</span>
<span class="sd">      relative tolerance as in :func:`numpy.allclose`</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    bool, str or None</span>
<span class="sd">      check result and the reason of fail if any</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># return True, None</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>


<div class="viewcode-block" id="Manifold._check_vector_on_tangent">
<a class="viewcode-back" href="../../../devguide.html#geoopt.manifolds.base.Manifold._check_vector_on_tangent">[docs]</a>
  <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
  <span class="k">def</span><span class="w"> </span><span class="nf">_check_vector_on_tangent</span><span class="p">(</span>
      <span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">u</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="mf">1e-5</span>
  <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span> <span class="nb">bool</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Util to check a vector belongs to the tangent space of a point.</span>

<span class="sd">    Exhaustive implementation for checking if</span>
<span class="sd">    a given point lies in the tangent space at x</span>
<span class="sd">    of the manifold. It should return a boolean</span>
<span class="sd">    indicating whether the test was passed</span>
<span class="sd">    and a reason of failure if check is not passed.</span>
<span class="sd">    You can assume assert_check_point is already</span>
<span class="sd">    passed beforehand</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x torch.Tensor</span>
<span class="sd">    u torch.Tensor</span>
<span class="sd">    atol : float</span>
<span class="sd">      absolute tolerance</span>
<span class="sd">    rtol :</span>
<span class="sd">      relative tolerance</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    bool, str or None</span>
<span class="sd">      check result and the reason of fail if any</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># return True, None</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>


<div class="viewcode-block" id="Manifold.extra_repr">
<a class="viewcode-back" href="../../../devguide.html#geoopt.manifolds.base.Manifold.extra_repr">[docs]</a>
  <span class="k">def</span><span class="w"> </span><span class="nf">extra_repr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="s2">&quot;&quot;</span></div>


  <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">extra</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extra_repr</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">extra</span><span class="p">:</span>
      <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;(</span><span class="si">{}</span><span class="s2">) manifold&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">extra</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot; manifold&quot;</span>

<div class="viewcode-block" id="Manifold.unpack_tensor">
<a class="viewcode-back" href="../../../devguide.html#geoopt.manifolds.base.Manifold.unpack_tensor">[docs]</a>
  <span class="k">def</span><span class="w"> </span><span class="nf">unpack_tensor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tensor</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Construct a point on the manifold.</span>

<span class="sd">    This method should help to work with product and compound manifolds.</span>
<span class="sd">    Internally all points on the manifold are stored in an intuitive format.</span>
<span class="sd">    However, there might be cases, when this representation is simpler or more efficient to store in</span>
<span class="sd">    a different way that is hard to use in practice.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    tensor : torch.Tensor</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    torch.Tensor</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">tensor</span></div>


<div class="viewcode-block" id="Manifold.pack_point">
<a class="viewcode-back" href="../../../devguide.html#geoopt.manifolds.base.Manifold.pack_point">[docs]</a>
  <span class="k">def</span><span class="w"> </span><span class="nf">pack_point</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">tensors</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Construct a tensor representation of a manifold point.</span>

<span class="sd">    In case of regular manifolds this will return the same tensor. However, for e.g. Product manifold</span>
<span class="sd">    this function will pack all non-batch dimensions.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    tensors : Tuple[torch.Tensor]</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    torch.Tensor</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tensors</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;1 tensor expected, got </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tensors</span><span class="p">)))</span>
    <span class="k">return</span> <span class="n">tensors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>


<div class="viewcode-block" id="Manifold.random">
<a class="viewcode-back" href="../../../devguide.html#geoopt.manifolds.base.Manifold.random">[docs]</a>
  <span class="k">def</span><span class="w"> </span><span class="nf">random</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Random sampling on the manifold.</span>

<span class="sd">    The exact implementation depends on manifold and usually does not follow all</span>
<span class="sd">    assumptions about uniform measure, etc.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>


<div class="viewcode-block" id="Manifold.origin">
<a class="viewcode-back" href="../../../devguide.html#geoopt.manifolds.base.Manifold.origin">[docs]</a>
  <span class="k">def</span><span class="w"> </span><span class="nf">origin</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">*</span><span class="n">size</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span>
    <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">device</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">seed</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">42</span>
  <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create some reasonable point on the manifold in a deterministic way.</span>

<span class="sd">    For some manifolds there may exist e.g. zero vector or some analogy.</span>
<span class="sd">    In case it is possible to define this special point, this point is returned with the desired size.</span>
<span class="sd">    In other case, the returned point is sampled on the manifold in a deterministic way.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    size : Union[int, Tuple[int]]</span>
<span class="sd">      the desired shape</span>
<span class="sd">    device : torch.device</span>
<span class="sd">      the desired device</span>
<span class="sd">    dtype : torch.dtype</span>
<span class="sd">      the desired dtype</span>
<span class="sd">    seed : Optional[int]</span>
<span class="sd">      A parameter controlling deterministic randomness for manifolds that do not provide ``.origin``,</span>
<span class="sd">      but provide ``.random``. (default: 42)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    torch.Tensor</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">seed</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
      <span class="c1"># we promise pseudorandom behaviour but do not want to modify global seed</span>
      <span class="n">state</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">get_rng_state</span><span class="p">()</span>
      <span class="n">torch</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">manual_seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
      <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="o">*</span><span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
      <span class="k">finally</span><span class="p">:</span>
        <span class="n">torch</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">set_rng_state</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="o">*</span><span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span></div>
</div>

</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../index.html">geoopt</a></h1>









<search id="searchbox" style="display: none" role="search">
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" placeholder="Search"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script><h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../manifolds.html">Manifolds</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../optimizers.html">Optimizers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tensors.html">Tensors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../samplers.html">Samplers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../extended.html">Extended Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../devguide.html">Developer Guide</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  <li><a href="../../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2018, Max Kochurov.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 8.1.3</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 1.0.0</a>
      
    </div>

    

    
  </body>
</html>